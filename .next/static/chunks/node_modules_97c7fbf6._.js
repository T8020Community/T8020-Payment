(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/cross-fetch/dist/browser-ponyfill.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Save global object in a variable
var __global__ = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || typeof global !== 'undefined' && global;
// Create an object that extends from __global__ without the fetch function
var __globalThis__ = function() {
    function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
    }
    F.prototype = __global__; // Needed for feature detection on whatwg-fetch's code
    return new F();
}();
// Wraps whatwg-fetch with a function scope to hijack the global object
// "globalThis" that's going to be patched
(function(globalThis1) {
    var irrelevant = function(exports1) {
        /* eslint-disable no-prototype-builtins */ var g = typeof globalThis1 !== 'undefined' && globalThis1 || typeof self !== 'undefined' && self || typeof global !== 'undefined' && global || {};
        var support = {
            searchParams: 'URLSearchParams' in g,
            iterable: 'Symbol' in g && 'iterator' in Symbol,
            blob: 'FileReader' in g && 'Blob' in g && function() {
                try {
                    new Blob();
                    return true;
                } catch (e) {
                    return false;
                }
            }(),
            formData: 'FormData' in g,
            arrayBuffer: 'ArrayBuffer' in g
        };
        function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
            var viewClasses = [
                '[object Int8Array]',
                '[object Uint8Array]',
                '[object Uint8ClampedArray]',
                '[object Int16Array]',
                '[object Uint16Array]',
                '[object Int32Array]',
                '[object Uint32Array]',
                '[object Float32Array]',
                '[object Float64Array]'
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
        }
        function normalizeName(name) {
            if (typeof name !== 'string') {
                name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
                throw new TypeError('Invalid character in header field name: "' + name + '"');
            }
            return name.toLowerCase();
        }
        function normalizeValue(value) {
            if (typeof value !== 'string') {
                value = String(value);
            }
            return value;
        }
        // Build a destructive iterator for the value list
        function iteratorFor(items) {
            var iterator = {
                next: function() {
                    var value = items.shift();
                    return {
                        done: value === undefined,
                        value: value
                    };
                }
            };
            if (support.iterable) {
                iterator[Symbol.iterator] = function() {
                    return iterator;
                };
            }
            return iterator;
        }
        function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
                headers.forEach(function(value, name) {
                    this.append(name, value);
                }, this);
            } else if (Array.isArray(headers)) {
                headers.forEach(function(header) {
                    if (header.length != 2) {
                        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
                    }
                    this.append(header[0], header[1]);
                }, this);
            } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function(name) {
                    this.append(name, headers[name]);
                }, this);
            }
        }
        Headers.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ', ' + value : value;
        };
        Headers.prototype['delete'] = function(name) {
            delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
            for(var name in this.map){
                if (this.map.hasOwnProperty(name)) {
                    callback.call(thisArg, this.map[name], name, this);
                }
            }
        };
        Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) {
                items.push(name);
            });
            return iteratorFor(items);
        };
        Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
                items.push(value);
            });
            return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) {
                items.push([
                    name,
                    value
                ]);
            });
            return iteratorFor(items);
        };
        if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
            if (body._noBody) return;
            if (body.bodyUsed) {
                return Promise.reject(new TypeError('Already read'));
            }
            body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
                reader.onload = function() {
                    resolve(reader.result);
                };
                reader.onerror = function() {
                    reject(reader.error);
                };
            });
        }
        function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
        }
        function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
            var encoding = match ? match[1] : 'utf-8';
            reader.readAsText(blob, encoding);
            return promise;
        }
        function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for(var i = 0; i < view.length; i++){
                chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join('');
        }
        function bufferClone(buf) {
            if (buf.slice) {
                return buf.slice(0);
            } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
            }
        }
        function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
                /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */ // eslint-disable-next-line no-self-assign
                this.bodyUsed = this.bodyUsed;
                this._bodyInit = body;
                if (!body) {
                    this._noBody = true;
                    this._bodyText = '';
                } else if (typeof body === 'string') {
                    this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                    this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                    this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                    this._bodyArrayBuffer = bufferClone(body.buffer);
                    // IE 10-11 can't handle a DataView body.
                    this._bodyInit = new Blob([
                        this._bodyArrayBuffer
                    ]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                    this._bodyArrayBuffer = bufferClone(body);
                } else {
                    this._bodyText = body = Object.prototype.toString.call(body);
                }
                if (!this.headers.get('content-type')) {
                    if (typeof body === 'string') {
                        this.headers.set('content-type', 'text/plain;charset=UTF-8');
                    } else if (this._bodyBlob && this._bodyBlob.type) {
                        this.headers.set('content-type', this._bodyBlob.type);
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                    }
                }
            };
            if (support.blob) {
                this.blob = function() {
                    var rejected = consumed(this);
                    if (rejected) {
                        return rejected;
                    }
                    if (this._bodyBlob) {
                        return Promise.resolve(this._bodyBlob);
                    } else if (this._bodyArrayBuffer) {
                        return Promise.resolve(new Blob([
                            this._bodyArrayBuffer
                        ]));
                    } else if (this._bodyFormData) {
                        throw new Error('could not read FormData body as blob');
                    } else {
                        return Promise.resolve(new Blob([
                            this._bodyText
                        ]));
                    }
                };
            }
            this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                    var isConsumed = consumed(this);
                    if (isConsumed) {
                        return isConsumed;
                    } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                        return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                    } else {
                        return Promise.resolve(this._bodyArrayBuffer);
                    }
                } else if (support.blob) {
                    return this.blob().then(readBlobAsArrayBuffer);
                } else {
                    throw new Error('could not read as ArrayBuffer');
                }
            };
            this.text = function() {
                var rejected = consumed(this);
                if (rejected) {
                    return rejected;
                }
                if (this._bodyBlob) {
                    return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as text');
                } else {
                    return Promise.resolve(this._bodyText);
                }
            };
            if (support.formData) {
                this.formData = function() {
                    return this.text().then(decode);
                };
            }
            this.json = function() {
                return this.text().then(JSON.parse);
            };
            return this;
        }
        // HTTP methods whose capitalization should be normalized
        var methods = [
            'CONNECT',
            'DELETE',
            'GET',
            'HEAD',
            'OPTIONS',
            'PATCH',
            'POST',
            'PUT',
            'TRACE'
        ];
        function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
            if (!(this instanceof Request)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
                if (input.bodyUsed) {
                    throw new TypeError('Already read');
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options.headers) {
                    this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;
                if (!body && input._bodyInit != null) {
                    body = input._bodyInit;
                    input.bodyUsed = true;
                }
            } else {
                this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || 'same-origin';
            if (options.headers || !this.headers) {
                this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || 'GET');
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal || function() {
                if ('AbortController' in g) {
                    var ctrl = new AbortController();
                    return ctrl.signal;
                }
            }();
            this.referrer = null;
            if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                throw new TypeError('Body not allowed for GET or HEAD requests');
            }
            this._initBody(body);
            if (this.method === 'GET' || this.method === 'HEAD') {
                if (options.cache === 'no-store' || options.cache === 'no-cache') {
                    // Search for a '_' parameter in the query string
                    var reParamSearch = /([?&])_=[^&]*/;
                    if (reParamSearch.test(this.url)) {
                        // If it already exists then set the value with the current time
                        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
                    } else {
                        // Otherwise add a new '_' parameter to the end with the current time
                        var reQueryString = /\?/;
                        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
                    }
                }
            }
        }
        Request.prototype.clone = function() {
            return new Request(this, {
                body: this._bodyInit
            });
        };
        function decode(body) {
            var form = new FormData();
            body.trim().split('&').forEach(function(bytes) {
                if (bytes) {
                    var split = bytes.split('=');
                    var name = split.shift().replace(/\+/g, ' ');
                    var value = split.join('=').replace(/\+/g, ' ');
                    form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
            });
            return form;
        }
        function parseHeaders(rawHeaders) {
            var headers = new Headers();
            // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
            // https://tools.ietf.org/html/rfc7230#section-3.2
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
            // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
            // https://github.com/github/fetch/issues/748
            // https://github.com/zloirock/core-js/issues/751
            preProcessedHeaders.split('\r').map(function(header) {
                return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
            }).forEach(function(line) {
                var parts = line.split(':');
                var key = parts.shift().trim();
                if (key) {
                    var value = parts.join(':').trim();
                    try {
                        headers.append(key, value);
                    } catch (error) {
                        console.warn('Response ' + error.message);
                    }
                }
            });
            return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
            if (!(this instanceof Response)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            if (!options) {
                options = {};
            }
            this.type = 'default';
            this.status = options.status === undefined ? 200 : options.status;
            if (this.status < 200 || this.status > 599) {
                throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
            }
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
            this.headers = new Headers(options.headers);
            this.url = options.url || '';
            this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
            });
        };
        Response.error = function() {
            var response = new Response(null, {
                status: 200,
                statusText: ''
            });
            response.ok = false;
            response.status = 0;
            response.type = 'error';
            return response;
        };
        var redirectStatuses = [
            301,
            302,
            303,
            307,
            308
        ];
        Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError('Invalid status code');
            }
            return new Response(null, {
                status: status,
                headers: {
                    location: url
                }
            });
        };
        exports1.DOMException = g.DOMException;
        try {
            new exports1.DOMException();
        } catch (err) {
            exports1.DOMException = function(message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
            };
            exports1.DOMException.prototype = Object.create(Error.prototype);
            exports1.DOMException.prototype.constructor = exports1.DOMException;
        }
        function fetch(input, init) {
            return new Promise(function(resolve, reject) {
                var request = new Request(input, init);
                if (request.signal && request.signal.aborted) {
                    return reject(new exports1.DOMException('Aborted', 'AbortError'));
                }
                var xhr = new XMLHttpRequest();
                function abortXhr() {
                    xhr.abort();
                }
                xhr.onload = function() {
                    var options = {
                        statusText: xhr.statusText,
                        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                    };
                    // This check if specifically for when a user fetches a file locally from the file system
                    // Only if the status is out of a normal range
                    if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
                        options.status = 200;
                    } else {
                        options.status = xhr.status;
                    }
                    options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                    var body = 'response' in xhr ? xhr.response : xhr.responseText;
                    setTimeout(function() {
                        resolve(new Response(body, options));
                    }, 0);
                };
                xhr.onerror = function() {
                    setTimeout(function() {
                        reject(new TypeError('Network request failed'));
                    }, 0);
                };
                xhr.ontimeout = function() {
                    setTimeout(function() {
                        reject(new TypeError('Network request timed out'));
                    }, 0);
                };
                xhr.onabort = function() {
                    setTimeout(function() {
                        reject(new exports1.DOMException('Aborted', 'AbortError'));
                    }, 0);
                };
                function fixUrl(url) {
                    try {
                        return url === '' && g.location.href ? g.location.href : url;
                    } catch (e) {
                        return url;
                    }
                }
                xhr.open(request.method, fixUrl(request.url), true);
                if (request.credentials === 'include') {
                    xhr.withCredentials = true;
                } else if (request.credentials === 'omit') {
                    xhr.withCredentials = false;
                }
                if ('responseType' in xhr) {
                    if (support.blob) {
                        xhr.responseType = 'blob';
                    } else if (support.arrayBuffer) {
                        xhr.responseType = 'arraybuffer';
                    }
                }
                if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
                    var names = [];
                    Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                        names.push(normalizeName(name));
                        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                    });
                    request.headers.forEach(function(value, name) {
                        if (names.indexOf(name) === -1) {
                            xhr.setRequestHeader(name, value);
                        }
                    });
                } else {
                    request.headers.forEach(function(value, name) {
                        xhr.setRequestHeader(name, value);
                    });
                }
                if (request.signal) {
                    request.signal.addEventListener('abort', abortXhr);
                    xhr.onreadystatechange = function() {
                        // DONE (success or failure)
                        if (xhr.readyState === 4) {
                            request.signal.removeEventListener('abort', abortXhr);
                        }
                    };
                }
                xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
            });
        }
        fetch.polyfill = true;
        if (!g.fetch) {
            g.fetch = fetch;
            g.Headers = Headers;
            g.Request = Request;
            g.Response = Response;
        }
        exports1.Headers = Headers;
        exports1.Request = Request;
        exports1.Response = Response;
        exports1.fetch = fetch;
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
        return exports1;
    }({});
})(__globalThis__);
// This is a ponyfill, so...
__globalThis__.fetch.ponyfill = true;
delete __globalThis__.fetch.polyfill;
// Choose between native implementation (__global__) or custom implementation (__globalThis__)
var ctx = __global__.fetch ? __global__ : __globalThis__;
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
;
exports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.
;
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
;
exports.Headers = ctx.Headers;
exports.Request = ctx.Request;
exports.Response = ctx.Response;
module.exports = exports;
}}),
"[project]/node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "HttpConnection": (()=>f),
    "default": (()=>f)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$browser$2d$ponyfill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cross-fetch/dist/browser-ponyfill.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$safe$2d$json$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/safe-json/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js [app-client] (ecmascript)");
;
;
;
;
var P = Object.defineProperty, w = Object.defineProperties, E = Object.getOwnPropertyDescriptors, c = Object.getOwnPropertySymbols, L = Object.prototype.hasOwnProperty, O = Object.prototype.propertyIsEnumerable, l = (r, t, e)=>t in r ? P(r, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : r[t] = e, p = (r, t)=>{
    for(var e in t || (t = {}))L.call(t, e) && l(r, e, t[e]);
    if (c) for (var e of c(t))O.call(t, e) && l(r, e, t[e]);
    return r;
}, v = (r, t)=>w(r, E(t));
const j = {
    Accept: "application/json",
    "Content-Type": "application/json"
}, T = "POST", d = {
    headers: j,
    method: T
}, g = 10;
class f {
    constructor(t, e = !1){
        if (this.url = t, this.disableProviderPing = e, this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"], this.isAvailable = !1, this.registering = !1, !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHttpUrl"])(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
        this.url = t, this.disableProviderPing = e;
    }
    get connected() {
        return this.isAvailable;
    }
    get connecting() {
        return this.registering;
    }
    on(t, e) {
        this.events.on(t, e);
    }
    once(t, e) {
        this.events.once(t, e);
    }
    off(t, e) {
        this.events.off(t, e);
    }
    removeListener(t, e) {
        this.events.removeListener(t, e);
    }
    async open(t = this.url) {
        await this.register(t);
    }
    async close() {
        if (!this.isAvailable) throw new Error("Connection already closed");
        this.onClose();
    }
    async send(t) {
        this.isAvailable || await this.register();
        try {
            const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$safe$2d$json$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeJsonStringify"])(t), s = await (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$browser$2d$ponyfill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.url, v(p({}, d), {
                body: e
            }))).json();
            this.onPayload({
                data: s
            });
        } catch (e) {
            this.onError(t.id, e);
        }
    }
    async register(t = this.url) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHttpUrl"])(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
        if (this.registering) {
            const e = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= e || this.events.listenerCount("open") >= e) && this.events.setMaxListeners(e + 1), new Promise((s, i)=>{
                this.events.once("register_error", (n)=>{
                    this.resetMaxListeners(), i(n);
                }), this.events.once("open", ()=>{
                    if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
                    s();
                });
            });
        }
        this.url = t, this.registering = !0;
        try {
            if (!this.disableProviderPing) {
                const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$safe$2d$json$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeJsonStringify"])({
                    id: 1,
                    jsonrpc: "2.0",
                    method: "test",
                    params: []
                });
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$browser$2d$ponyfill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(t, v(p({}, d), {
                    body: e
                }));
            }
            this.onOpen();
        } catch (e) {
            const s = this.parseError(e);
            throw this.events.emit("register_error", s), this.onClose(), s;
        }
    }
    onOpen() {
        this.isAvailable = !0, this.registering = !1, this.events.emit("open");
    }
    onClose() {
        this.isAvailable = !1, this.registering = !1, this.events.emit("close");
    }
    onPayload(t) {
        if (typeof t.data > "u") return;
        const e = typeof t.data == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$safe$2d$json$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeJsonParse"])(t.data) : t.data;
        this.events.emit("payload", e);
    }
    onError(t, e) {
        const s = this.parseError(e), i = s.message || s.toString(), n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatJsonRpcError"])(t, i);
        this.events.emit("payload", n);
    }
    parseError(t, e = this.url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseConnectionError"])(t, e, "HTTP");
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > g && this.events.setMaxListeners(g);
    }
}
;
 //# sourceMappingURL=index.es.js.map
}}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/universal-provider/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "UniversalProvider": (()=>es),
    "default": (()=>x)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$sign$2d$client$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/sign-client/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$logger$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/logger/dist/index.es.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pino$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pino$3e$__ = __turbopack_context__.i("[project]/node_modules/pino/browser.js [app-client] (ecmascript) <export default as pino>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$logger$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/logger/dist/index.es.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/events/events.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const tt = "error", Nt = "wss://relay.walletconnect.org", St = "wc", Dt = "universal_provider", _ = `${St}@2:${Dt}:`, et = "https://rpc.walletconnect.org/v1/", w = "generic", qt = `${et}bundler`, d = {
    DEFAULT_CHAIN_CHANGED: "default_chain_changed"
};
function jt() {}
function B(s) {
    return s == null || typeof s != "object" && typeof s != "function";
}
function G(s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function Rt(s) {
    if (B(s)) return s;
    if (Array.isArray(s) || G(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
    const t = Object.getPrototypeOf(s), e = t.constructor;
    if (s instanceof Date || s instanceof Map || s instanceof Set) return new e(s);
    if (s instanceof RegExp) {
        const i = new e(s);
        return i.lastIndex = s.lastIndex, i;
    }
    if (s instanceof DataView) return new e(s.buffer.slice(0));
    if (s instanceof Error) {
        const i = new e(s.message);
        return i.stack = s.stack, i.name = s.name, i.cause = s.cause, i;
    }
    if (typeof File < "u" && s instanceof File) return new e([
        s
    ], s.name, {
        type: s.type,
        lastModified: s.lastModified
    });
    if (typeof s == "object") {
        const i = Object.create(t);
        return Object.assign(i, s);
    }
    return s;
}
function st(s) {
    return typeof s == "object" && s !== null;
}
function it(s) {
    return Object.getOwnPropertySymbols(s).filter((t)=>Object.prototype.propertyIsEnumerable.call(s, t));
}
function rt(s) {
    return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
const _t = "[object RegExp]", nt = "[object String]", at = "[object Number]", ct = "[object Boolean]", ot = "[object Arguments]", Ut = "[object Symbol]", Ft = "[object Date]", Lt = "[object Map]", xt = "[object Set]", Mt = "[object Array]", Bt = "[object ArrayBuffer]", Gt = "[object Object]", Jt = "[object DataView]", zt = "[object Uint8Array]", kt = "[object Uint8ClampedArray]", Wt = "[object Uint16Array]", Kt = "[object Uint32Array]", Vt = "[object Int8Array]", Xt = "[object Int16Array]", Yt = "[object Int32Array]", Qt = "[object Float32Array]", Zt = "[object Float64Array]";
function Tt(s, t) {
    return y(s, void 0, s, new Map, t);
}
function y(s, t, e, i = new Map, r = void 0) {
    const a = r?.(s, t, e, i);
    if (a != null) return a;
    if (B(s)) return s;
    if (i.has(s)) return i.get(s);
    if (Array.isArray(s)) {
        const n = new Array(s.length);
        i.set(s, n);
        for(let c = 0; c < s.length; c++)n[c] = y(s[c], c, e, i, r);
        return Object.hasOwn(s, "index") && (n.index = s.index), Object.hasOwn(s, "input") && (n.input = s.input), n;
    }
    if (s instanceof Date) return new Date(s.getTime());
    if (s instanceof RegExp) {
        const n = new RegExp(s.source, s.flags);
        return n.lastIndex = s.lastIndex, n;
    }
    if (s instanceof Map) {
        const n = new Map;
        i.set(s, n);
        for (const [c, h] of s)n.set(c, y(h, c, e, i, r));
        return n;
    }
    if (s instanceof Set) {
        const n = new Set;
        i.set(s, n);
        for (const c of s)n.add(y(c, void 0, e, i, r));
        return n;
    }
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] < "u" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(s)) return s.subarray();
    if (G(s)) {
        const n = new (Object.getPrototypeOf(s)).constructor(s.length);
        i.set(s, n);
        for(let c = 0; c < s.length; c++)n[c] = y(s[c], c, e, i, r);
        return n;
    }
    if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
    if (s instanceof DataView) {
        const n = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
        return i.set(s, n), g(n, s, e, i, r), n;
    }
    if (typeof File < "u" && s instanceof File) {
        const n = new File([
            s
        ], s.name, {
            type: s.type
        });
        return i.set(s, n), g(n, s, e, i, r), n;
    }
    if (s instanceof Blob) {
        const n = new Blob([
            s
        ], {
            type: s.type
        });
        return i.set(s, n), g(n, s, e, i, r), n;
    }
    if (s instanceof Error) {
        const n = new s.constructor;
        return i.set(s, n), n.message = s.message, n.name = s.name, n.stack = s.stack, n.cause = s.cause, g(n, s, e, i, r), n;
    }
    if (typeof s == "object" && te(s)) {
        const n = Object.create(Object.getPrototypeOf(s));
        return i.set(s, n), g(n, s, e, i, r), n;
    }
    return s;
}
function g(s, t, e = s, i, r) {
    const a = [
        ...Object.keys(t),
        ...it(t)
    ];
    for(let n = 0; n < a.length; n++){
        const c = a[n], h = Object.getOwnPropertyDescriptor(s, c);
        (h == null || h.writable) && (s[c] = y(t[c], c, e, i, r));
    }
}
function te(s) {
    switch(rt(s)){
        case ot:
        case Mt:
        case Bt:
        case Jt:
        case ct:
        case Ft:
        case Qt:
        case Zt:
        case Vt:
        case Xt:
        case Yt:
        case Lt:
        case at:
        case Gt:
        case _t:
        case xt:
        case nt:
        case Ut:
        case zt:
        case kt:
        case Wt:
        case Kt:
            return !0;
        default:
            return !1;
    }
}
function ee(s, t) {
    return Tt(s, (e, i, r, a)=>{
        const n = t?.(e, i, r, a);
        if (n != null) return n;
        if (typeof s == "object") switch(Object.prototype.toString.call(s)){
            case at:
            case nt:
            case ct:
                {
                    const c = new s.constructor(s?.valueOf());
                    return g(c, s), c;
                }
            case ot:
                {
                    const c = {};
                    return g(c, s), c.length = s.length, c[Symbol.iterator] = s[Symbol.iterator], c;
                }
            default:
                return;
        }
    });
}
function ht(s) {
    return ee(s);
}
function pt(s) {
    return s !== null && typeof s == "object" && rt(s) === "[object Arguments]";
}
function se(s) {
    return G(s);
}
function ie(s) {
    if (typeof s != "object" || s == null) return !1;
    if (Object.getPrototypeOf(s) === null) return !0;
    if (Object.prototype.toString.call(s) !== "[object Object]") {
        const e = s[Symbol.toStringTag];
        return e == null || !Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)?.writable ? !1 : s.toString() === `[object ${e}]`;
    }
    let t = s;
    for(; Object.getPrototypeOf(t) !== null;)t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(s) === t;
}
function re(s, ...t) {
    const e = t.slice(0, -1), i = t[t.length - 1];
    let r = s;
    for(let a = 0; a < e.length; a++){
        const n = e[a];
        r = U(r, n, i, new Map);
    }
    return r;
}
function U(s, t, e, i) {
    if (B(s) && (s = Object(s)), t == null || typeof t != "object") return s;
    if (i.has(t)) return Rt(i.get(t));
    if (i.set(t, s), Array.isArray(t)) {
        t = t.slice();
        for(let a = 0; a < t.length; a++)t[a] = t[a] ?? void 0;
    }
    const r = [
        ...Object.keys(t),
        ...it(t)
    ];
    for(let a = 0; a < r.length; a++){
        const n = r[a];
        let c = t[n], h = s[n];
        if (pt(c) && (c = {
            ...c
        }), pt(h) && (h = {
            ...h
        }), typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] < "u" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(c) && (c = ht(c)), Array.isArray(c)) if (typeof h == "object" && h != null) {
            const j = [], R = Reflect.ownKeys(h);
            for(let f = 0; f < R.length; f++){
                const X = R[f];
                j[X] = h[X];
            }
            h = j;
        } else h = [];
        const v = e(h, c, n, s, t, i);
        v != null ? s[n] = v : Array.isArray(c) || st(h) && st(c) ? s[n] = U(h, c, e, i) : h == null && ie(c) ? s[n] = U({}, c, e, i) : h == null && se(c) ? s[n] = ht(c) : (h === void 0 || c !== void 0) && (s[n] = c);
    }
    return s;
}
function ne(s, ...t) {
    return re(s, ...t, jt);
}
var ae = Object.defineProperty, ce = Object.defineProperties, oe = Object.getOwnPropertyDescriptors, dt = Object.getOwnPropertySymbols, he = Object.prototype.hasOwnProperty, pe = Object.prototype.propertyIsEnumerable, ut = (s, t, e)=>t in s ? ae(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, F = (s, t)=>{
    for(var e in t || (t = {}))he.call(t, e) && ut(s, e, t[e]);
    if (dt) for (var e of dt(t))pe.call(t, e) && ut(s, e, t[e]);
    return s;
}, de = (s, t)=>ce(s, oe(t));
function p(s, t, e) {
    var i;
    const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseChainId"])(s);
    return ((i = t.rpcMap) == null ? void 0 : i[r.reference]) || `${et}?chainId=${r.namespace}:${r.reference}&projectId=${e}`;
}
function P(s) {
    return s.includes(":") ? s.split(":")[1] : s;
}
function lt(s) {
    return s.map((t)=>`${t.split(":")[0]}:${t.split(":")[1]}`);
}
function ue(s, t) {
    const e = Object.keys(t.namespaces).filter((r)=>r.includes(s));
    if (!e.length) return [];
    const i = [];
    return e.forEach((r)=>{
        const a = t.namespaces[r].accounts;
        i.push(...a);
    }), i;
}
function J(s = {}, t = {}) {
    const e = ft(s), i = ft(t);
    return ne(e, i);
}
function ft(s) {
    var t, e, i, r;
    const a = {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidObject"])(s)) return a;
    for (const [n, c] of Object.entries(s)){
        const h = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCaipNamespace"])(n) ? [
            n
        ] : c.chains, v = c.methods || [], j = c.events || [], R = c.rpcMap || {}, f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(n);
        a[f] = de(F(F({}, a[f]), c), {
            chains: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeArrays"])(h, (t = a[f]) == null ? void 0 : t.chains),
            methods: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeArrays"])(v, (e = a[f]) == null ? void 0 : e.methods),
            events: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeArrays"])(j, (i = a[f]) == null ? void 0 : i.events),
            rpcMap: F(F({}, R), (r = a[f]) == null ? void 0 : r.rpcMap)
        });
    }
    return a;
}
function le(s) {
    return s.includes(":") ? s.split(":")[2] : s;
}
function mt(s) {
    const t = {};
    for (const [e, i] of Object.entries(s)){
        const r = i.methods || [], a = i.events || [], n = i.accounts || [], c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCaipNamespace"])(e) ? [
            e
        ] : i.chains ? i.chains : lt(i.accounts);
        t[e] = {
            chains: c,
            methods: r,
            events: a,
            accounts: n
        };
    }
    return t;
}
function z(s) {
    return typeof s == "number" ? s : s.includes("0x") ? parseInt(s, 16) : (s = s.includes(":") ? s.split(":")[1] : s, isNaN(Number(s)) ? s : Number(s));
}
const vt = {}, o = (s)=>vt[s], k = (s, t)=>{
    vt[s] = t;
};
var fe = Object.defineProperty, me = (s, t, e)=>t in s ? fe(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, b = (s, t, e)=>me(s, typeof t != "symbol" ? t + "" : t, e);
class ve {
    constructor(t){
        b(this, "name", "polkadot"), b(this, "client"), b(this, "httpProviders"), b(this, "events"), b(this, "namespace"), b(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]) || [] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            var i;
            const r = P(e);
            t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var ge = Object.defineProperty, Pe = Object.defineProperties, we = Object.getOwnPropertyDescriptors, gt = Object.getOwnPropertySymbols, ye = Object.prototype.hasOwnProperty, be = Object.prototype.propertyIsEnumerable, W = (s, t, e)=>t in s ? ge(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, Pt = (s, t)=>{
    for(var e in t || (t = {}))ye.call(t, e) && W(s, e, t[e]);
    if (gt) for (var e of gt(t))be.call(t, e) && W(s, e, t[e]);
    return s;
}, wt = (s, t)=>Pe(s, we(t)), I = (s, t, e)=>W(s, typeof t != "symbol" ? t + "" : t, e);
class Ie {
    constructor(t){
        I(this, "name", "eip155"), I(this, "client"), I(this, "chainId"), I(this, "namespace"), I(this, "httpProviders"), I(this, "events"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
    }
    async request(t) {
        switch(t.request.method){
            case "eth_requestAccounts":
                return this.getAccounts();
            case "eth_accounts":
                return this.getAccounts();
            case "wallet_switchEthereumChain":
                return await this.handleSwitchChain(t);
            case "eth_chainId":
                return parseInt(this.getDefaultChain());
            case "wallet_getCapabilities":
                return await this.getCapabilities(t);
            case "wallet_getCallsStatus":
                return await this.getCallStatus(t);
        }
        return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    setDefaultChain(t, e) {
        this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId.toString();
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    createHttpProvider(t, e) {
        const i = e || p(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpConnection"](i, o("disableProviderPing")));
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            var i;
            const r = parseInt(P(e));
            t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
        }), t;
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? [
            ...new Set(t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]))
        ] : [];
    }
    getHttpProvider() {
        const t = this.chainId, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    async handleSwitchChain(t) {
        var e, i;
        let r = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : "0x0";
        r = r.startsWith("0x") ? r : `0x${r}`;
        const a = parseInt(r, 16);
        if (this.isChainApproved(a)) this.setDefaultChain(`${a}`);
        else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
            topic: t.topic,
            request: {
                method: t.request.method,
                params: [
                    {
                        chainId: r
                    }
                ]
            },
            chainId: (i = this.namespace.chains) == null ? void 0 : i[0]
        }), this.setDefaultChain(`${a}`);
        else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
        return null;
    }
    isChainApproved(t) {
        return this.namespace.chains.includes(`${this.name}:${t}`);
    }
    async getCapabilities(t) {
        var e, i, r;
        const a = (i = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i[0];
        if (!a) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
        const n = this.client.session.get(t.topic), c = ((r = n?.sessionProperties) == null ? void 0 : r.capabilities) || {};
        if (c != null && c[a]) return c?.[a];
        const h = await this.client.request(t);
        try {
            await this.client.session.update(t.topic, {
                sessionProperties: wt(Pt({}, n.sessionProperties || {}), {
                    capabilities: wt(Pt({}, c || {}), {
                        [a]: h
                    })
                })
            });
        } catch (v) {
            console.warn("Failed to update session with capabilities", v);
        }
        return h;
    }
    async getCallStatus(t) {
        var e, i;
        const r = this.client.session.get(t.topic), a = (e = r.sessionProperties) == null ? void 0 : e.bundler_name;
        if (a) {
            const c = this.getBundlerUrl(t.chainId, a);
            try {
                return await this.getUserOperationReceipt(c, t);
            } catch (h) {
                console.warn("Failed to fetch call status from bundler", h, c);
            }
        }
        const n = (i = r.sessionProperties) == null ? void 0 : i.bundler_url;
        if (n) try {
            return await this.getUserOperationReceipt(n, t);
        } catch (c) {
            console.warn("Failed to fetch call status from custom bundler", c, n);
        }
        if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);
        throw new Error("Fetching call status not approved by the wallet.");
    }
    async getUserOperationReceipt(t, e) {
        var i;
        const r = new URL(t), a = await fetch(r, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatJsonRpcRequest"])("eth_getUserOperationReceipt", [
                (i = e.request.params) == null ? void 0 : i[0]
            ]))
        });
        if (!a.ok) throw new Error(`Failed to fetch user operation receipt - ${a.status}`);
        return await a.json();
    }
    getBundlerUrl(t, e) {
        return `${qt}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;
    }
}
var $e = Object.defineProperty, Oe = (s, t, e)=>t in s ? $e(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, $ = (s, t, e)=>Oe(s, typeof t != "symbol" ? t + "" : t, e);
class Ae {
    constructor(t){
        $(this, "name", "solana"), $(this, "client"), $(this, "httpProviders"), $(this, "events"), $(this, "namespace"), $(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? [
            ...new Set(t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            var i;
            const r = P(e);
            t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var He = Object.defineProperty, Ee = (s, t, e)=>t in s ? He(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, O = (s, t, e)=>Ee(s, typeof t != "symbol" ? t + "" : t, e);
class Ce {
    constructor(t){
        O(this, "name", "cosmos"), O(this, "client"), O(this, "httpProviders"), O(this, "events"), O(this, "namespace"), O(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? [
            ...new Set(t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            var i;
            const r = P(e);
            t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var Ne = Object.defineProperty, Se = (s, t, e)=>t in s ? Ne(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, A = (s, t, e)=>Se(s, typeof t != "symbol" ? t + "" : t, e);
class De {
    constructor(t){
        A(this, "name", "algorand"), A(this, "client"), A(this, "httpProviders"), A(this, "events"), A(this, "namespace"), A(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        if (!this.httpProviders[t]) {
            const i = e || p(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
            if ("TURBOPACK compile-time falsy", 0) {
                "TURBOPACK unreachable";
            }
            this.setHttpProvider(t, i);
        }
        this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? [
            ...new Set(t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            var i;
            t[e] = this.createHttpProvider(e, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace, this.client.core.projectId);
        return typeof i > "u" ? void 0 : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var qe = Object.defineProperty, je = (s, t, e)=>t in s ? qe(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, H = (s, t, e)=>je(s, typeof t != "symbol" ? t + "" : t, e);
class Re {
    constructor(t){
        H(this, "name", "cip34"), H(this, "client"), H(this, "httpProviders"), H(this, "events"), H(this, "namespace"), H(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? [
            ...new Set(t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            const i = this.getCardanoRPCUrl(e), r = P(e);
            t[r] = this.createHttpProvider(r, i);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    getCardanoRPCUrl(t) {
        const e = this.namespace.rpcMap;
        if (e) return e[t];
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || this.getCardanoRPCUrl(t);
        if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var _e = Object.defineProperty, Ue = (s, t, e)=>t in s ? _e(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, E = (s, t, e)=>Ue(s, typeof t != "symbol" ? t + "" : t, e);
class Fe {
    constructor(t){
        E(this, "name", "elrond"), E(this, "client"), E(this, "httpProviders"), E(this, "events"), E(this, "namespace"), E(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? [
            ...new Set(t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            var i;
            const r = P(e);
            t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var Le = Object.defineProperty, xe = (s, t, e)=>t in s ? Le(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, C = (s, t, e)=>xe(s, typeof t != "symbol" ? t + "" : t, e);
class Me {
    constructor(t){
        C(this, "name", "multiversx"), C(this, "client"), C(this, "httpProviders"), C(this, "events"), C(this, "namespace"), C(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? [
            ...new Set(t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            var i;
            const r = P(e);
            t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var Be = Object.defineProperty, Ge = (s, t, e)=>t in s ? Be(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, N = (s, t, e)=>Ge(s, typeof t != "symbol" ? t + "" : t, e);
class Je {
    constructor(t){
        N(this, "name", "near"), N(this, "client"), N(this, "httpProviders"), N(this, "events"), N(this, "namespace"), N(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        if (this.chainId = t, !this.httpProviders[t]) {
            const i = e || p(`${this.name}:${t}`, this.namespace);
            if ("TURBOPACK compile-time falsy", 0) {
                "TURBOPACK unreachable";
            }
            this.setHttpProvider(t, i);
        }
        this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]) || [] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            var i;
            t[e] = this.createHttpProvider(e, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace);
        return typeof i > "u" ? void 0 : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var ze = Object.defineProperty, ke = (s, t, e)=>t in s ? ze(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, S = (s, t, e)=>ke(s, typeof t != "symbol" ? t + "" : t, e);
class We {
    constructor(t){
        S(this, "name", "tezos"), S(this, "client"), S(this, "httpProviders"), S(this, "events"), S(this, "namespace"), S(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace = Object.assign(this.namespace, t);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
    }
    setDefaultChain(t, e) {
        if (this.chainId = t, !this.httpProviders[t]) {
            const i = e || p(`${this.name}:${t}`, this.namespace);
            if ("TURBOPACK compile-time falsy", 0) {
                "TURBOPACK unreachable";
            }
            this.setHttpProvider(t, i);
        }
        this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]) || [] : [];
    }
    createHttpProviders() {
        const t = {};
        return this.namespace.chains.forEach((e)=>{
            t[e] = this.createHttpProvider(e);
        }), t;
    }
    getHttpProvider() {
        const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace);
        return typeof i > "u" ? void 0 : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i));
    }
}
var Ke = Object.defineProperty, Ve = (s, t, e)=>t in s ? Ke(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, D = (s, t, e)=>Ve(s, typeof t != "symbol" ? t + "" : t, e);
class Xe {
    constructor(t){
        D(this, "name", w), D(this, "client"), D(this, "httpProviders"), D(this, "events"), D(this, "namespace"), D(this, "chainId"), this.namespace = t.namespace, this.events = o("events"), this.client = o("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(t) {
        this.namespace.chains = [
            ...new Set((this.namespace.chains || []).concat(t.chains || []))
        ], this.namespace.accounts = [
            ...new Set((this.namespace.accounts || []).concat(t.accounts || []))
        ], this.namespace.methods = [
            ...new Set((this.namespace.methods || []).concat(t.methods || []))
        ], this.namespace.events = [
            ...new Set((this.namespace.events || []).concat(t.events || []))
        ], this.httpProviders = this.createHttpProviders();
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(t) {
        return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);
    }
    setDefaultChain(t, e) {
        this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t = this.namespace.chains[0];
        if (!t) throw new Error("ChainId not found");
        return t.split(":")[1];
    }
    getAccounts() {
        const t = this.namespace.accounts;
        return t ? [
            ...new Set(t.filter((e)=>e.split(":")[1] === this.chainId.toString()).map((e)=>e.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        var t, e;
        const i = {};
        return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach((r)=>{
            const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseChainId"])(r);
            i[`${a.namespace}:${a.reference}`] = this.createHttpProvider(r);
        }), i;
    }
    getHttpProvider(t) {
        const e = this.httpProviders[t];
        if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
        return e;
    }
    setHttpProvider(t, e) {
        const i = this.createHttpProvider(t, e);
        i && (this.httpProviders[t] = i);
    }
    createHttpProvider(t, e) {
        const i = e || p(t, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, o("disableProviderPing")));
    }
}
var Ye = Object.defineProperty, Qe = Object.defineProperties, Ze = Object.getOwnPropertyDescriptors, yt = Object.getOwnPropertySymbols, Te = Object.prototype.hasOwnProperty, ts = Object.prototype.propertyIsEnumerable, K = (s, t, e)=>t in s ? Ye(s, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : s[t] = e, L = (s, t)=>{
    for(var e in t || (t = {}))Te.call(t, e) && K(s, e, t[e]);
    if (yt) for (var e of yt(t))ts.call(t, e) && K(s, e, t[e]);
    return s;
}, V = (s, t)=>Qe(s, Ze(t)), u = (s, t, e)=>K(s, typeof t != "symbol" ? t + "" : t, e);
class x {
    constructor(t){
        u(this, "client"), u(this, "namespaces"), u(this, "optionalNamespaces"), u(this, "sessionProperties"), u(this, "scopedProperties"), u(this, "events", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]), u(this, "rpcProviders", {}), u(this, "session"), u(this, "providerOpts"), u(this, "logger"), u(this, "uri"), u(this, "disableProviderPing", !1), this.providerOpts = t, this.logger = typeof t?.logger < "u" && typeof t?.logger != "string" ? t.logger : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pino$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pino$3e$__["pino"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$logger$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getDefaultLoggerOptions"])({
            level: t?.logger || tt
        })), this.disableProviderPing = t?.disableProviderPing || !1;
    }
    static async init(t) {
        const e = new x(t);
        return await e.initialize(), e;
    }
    async request(t, e, i) {
        const [r, a] = this.validateChain(e);
        if (!this.session) throw new Error("Please call connect() before request()");
        return await this.getProvider(r).request({
            request: L({}, t),
            chainId: `${r}:${a}`,
            topic: this.session.topic,
            expiry: i
        });
    }
    sendAsync(t, e, i, r) {
        const a = new Date().getTime();
        this.request(t, i, r).then((n)=>e(null, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatJsonRpcResult"])(a, n))).catch((n)=>e(n, void 0));
    }
    async enable() {
        if (!this.client) throw new Error("Sign Client not initialized");
        return this.session || await this.connect({
            namespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties
        }), await this.requestAccounts();
    }
    async disconnect() {
        var t;
        if (!this.session) throw new Error("Please call connect() before enable()");
        await this.client.disconnect({
            topic: (t = this.session) == null ? void 0 : t.topic,
            reason: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSdkError"])("USER_DISCONNECTED")
        }), await this.cleanup();
    }
    async connect(t) {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
    }
    async authenticate(t, e) {
        if (!this.client) throw new Error("Sign Client not initialized");
        this.setNamespaces(t), await this.cleanupPendingPairings();
        const { uri: i, response: r } = await this.client.authenticate(t, e);
        i && (this.uri = i, this.events.emit("display_uri", i));
        const a = await r();
        if (this.session = a.session, this.session) {
            const n = mt(this.session.namespaces);
            this.namespaces = J(this.namespaces, n), await this.persist("namespaces", this.namespaces), this.onConnect();
        }
        return a;
    }
    on(t, e) {
        this.events.on(t, e);
    }
    once(t, e) {
        this.events.once(t, e);
    }
    removeListener(t, e) {
        this.events.removeListener(t, e);
    }
    off(t, e) {
        this.events.off(t, e);
    }
    get isWalletConnect() {
        return !0;
    }
    async pair(t) {
        const { uri: e, approval: i } = await this.client.connect({
            pairingTopic: t,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties
        });
        e && (this.uri = e, this.events.emit("display_uri", e));
        const r = await i();
        this.session = r;
        const a = mt(r.namespaces);
        return this.namespaces = J(this.namespaces, a), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
    }
    setDefaultChain(t, e) {
        try {
            if (!this.session) return;
            const [i, r] = this.validateChain(t), a = this.getProvider(i);
            a.name === w ? a.setDefaultChain(`${i}:${r}`, e) : a.setDefaultChain(r, e);
        } catch (i) {
            if (!/Please call connect/.test(i.message)) throw i;
        }
    }
    async cleanupPendingPairings(t = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        const e = this.client.pairing.getAll();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidArray"])(e)) {
            for (const i of e)t.deletePairings ? this.client.core.expirer.set(i.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i.topic);
            this.logger.info(`Inactive pairings cleared: ${e.length}`);
        }
    }
    abortPairingAttempt() {
        this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
    }
    async checkStorage() {
        this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
    }
    async initialize() {
        this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
    }
    async createClient() {
        var t, e;
        if (this.client = this.providerOpts.client || await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$sign$2d$client$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].init({
            core: this.providerOpts.core,
            logger: this.providerOpts.logger || tt,
            relayUrl: this.providerOpts.relayUrl || Nt,
            projectId: this.providerOpts.projectId,
            metadata: this.providerOpts.metadata,
            storageOptions: this.providerOpts.storageOptions,
            storage: this.providerOpts.storage,
            name: this.providerOpts.name,
            customStoragePrefix: this.providerOpts.customStoragePrefix,
            telemetryEnabled: this.providerOpts.telemetryEnabled
        }), this.providerOpts.session) try {
            this.session = this.client.session.get(this.providerOpts.session.topic);
        } catch (i) {
            throw this.logger.error("Failed to get session", i), new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);
        }
        else {
            const i = this.client.session.getAll();
            this.session = i[0];
        }
        this.logger.trace("SignClient Initialized");
    }
    createProviders() {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
        const t = [
            ...new Set(Object.keys(this.session.namespaces).map((e)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(e)))
        ];
        k("client", this.client), k("events", this.events), k("disableProviderPing", this.disableProviderPing), t.forEach((e)=>{
            if (!this.session) return;
            const i = ue(e, this.session), r = lt(i), a = J(this.namespaces, this.optionalNamespaces), n = V(L({}, a[e]), {
                accounts: i,
                chains: r
            });
            switch(e){
                case "eip155":
                    this.rpcProviders[e] = new Ie({
                        namespace: n
                    });
                    break;
                case "algorand":
                    this.rpcProviders[e] = new De({
                        namespace: n
                    });
                    break;
                case "solana":
                    this.rpcProviders[e] = new Ae({
                        namespace: n
                    });
                    break;
                case "cosmos":
                    this.rpcProviders[e] = new Ce({
                        namespace: n
                    });
                    break;
                case "polkadot":
                    this.rpcProviders[e] = new ve({
                        namespace: n
                    });
                    break;
                case "cip34":
                    this.rpcProviders[e] = new Re({
                        namespace: n
                    });
                    break;
                case "elrond":
                    this.rpcProviders[e] = new Fe({
                        namespace: n
                    });
                    break;
                case "multiversx":
                    this.rpcProviders[e] = new Me({
                        namespace: n
                    });
                    break;
                case "near":
                    this.rpcProviders[e] = new Je({
                        namespace: n
                    });
                    break;
                case "tezos":
                    this.rpcProviders[e] = new We({
                        namespace: n
                    });
                    break;
                default:
                    this.rpcProviders[w] ? this.rpcProviders[w].updateNamespace(n) : this.rpcProviders[w] = new Xe({
                        namespace: n
                    });
            }
        });
    }
    registerEventListeners() {
        if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", (t)=>{
            var e;
            const { topic: i } = t;
            i === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit("session_ping", t);
        }), this.client.on("session_event", (t)=>{
            var e;
            const { params: i, topic: r } = t;
            if (r !== ((e = this.session) == null ? void 0 : e.topic)) return;
            const { event: a } = i;
            if (a.name === "accountsChanged") {
                const n = a.data;
                n && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidArray"])(n) && this.events.emit("accountsChanged", n.map(le));
            } else if (a.name === "chainChanged") {
                const n = i.chainId, c = i.event.data, h = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(n), v = z(n) !== z(c) ? `${h}:${z(c)}` : n;
                this.onChainChanged(v);
            } else this.events.emit(a.name, a.data);
            this.events.emit("session_event", t);
        }), this.client.on("session_update", ({ topic: t, params: e })=>{
            var i, r;
            if (t !== ((i = this.session) == null ? void 0 : i.topic)) return;
            const { namespaces: a } = e, n = (r = this.client) == null ? void 0 : r.session.get(t);
            this.session = V(L({}, n), {
                namespaces: a
            }), this.onSessionUpdate(), this.events.emit("session_update", {
                topic: t,
                params: e
            });
        }), this.client.on("session_delete", async (t)=>{
            var e;
            t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", V(L({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSdkError"])("USER_DISCONNECTED")), {
                data: t.topic
            })));
        }), this.on(d.DEFAULT_CHAIN_CHANGED, (t)=>{
            this.onChainChanged(t, !0);
        });
    }
    getProvider(t) {
        return this.rpcProviders[t] || this.rpcProviders[w];
    }
    onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach((t)=>{
            var e;
            this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);
        });
    }
    setNamespaces(t) {
        const { namespaces: e, optionalNamespaces: i, sessionProperties: r, scopedProperties: a } = t;
        e && Object.keys(e).length && (this.namespaces = e), i && Object.keys(i).length && (this.optionalNamespaces = i), this.sessionProperties = r, this.scopedProperties = a;
    }
    validateChain(t) {
        const [e, i] = t?.split(":") || [
            "",
            ""
        ];
        if (!this.namespaces || !Object.keys(this.namespaces).length) return [
            e,
            i
        ];
        if (e && !Object.keys(this.namespaces || {}).map((n)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(n)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);
        if (e && i) return [
            e,
            i
        ];
        const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(Object.keys(this.namespaces)[0]), a = this.rpcProviders[r].getDefaultChain();
        return [
            r,
            a
        ];
    }
    async requestAccounts() {
        const [t] = this.validateChain();
        return await this.getProvider(t).requestAccounts();
    }
    async onChainChanged(t, e = !1) {
        if (!this.namespaces) return;
        const [i, r] = this.validateChain(t);
        r && (e || this.getProvider(i).setDefaultChain(r), this.namespaces[i] ? this.namespaces[i].defaultChain = r : this.namespaces[`${i}:${r}`] ? this.namespaces[`${i}:${r}`].defaultChain = r : this.namespaces[`${i}:${r}`] = {
            defaultChain: r
        }, this.events.emit("chainChanged", r), await this.persist("namespaces", this.namespaces));
    }
    onConnect() {
        this.createProviders(), this.events.emit("connect", {
            session: this.session
        });
    }
    async cleanup() {
        this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({
            deletePairings: !0
        }), await this.cleanupStorage();
    }
    async persist(t, e) {
        var i;
        const r = ((i = this.session) == null ? void 0 : i.topic) || "";
        await this.client.core.storage.setItem(`${_}/${t}${r}`, e);
    }
    async getFromStore(t) {
        var e;
        const i = ((e = this.session) == null ? void 0 : e.topic) || "";
        return await this.client.core.storage.getItem(`${_}/${t}${i}`);
    }
    async deleteFromStore(t) {
        var e;
        const i = ((e = this.session) == null ? void 0 : e.topic) || "";
        await this.client.core.storage.removeItem(`${_}/${t}${i}`);
    }
    async cleanupStorage() {
        var t;
        try {
            if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;
            const e = await this.client.core.storage.getKeys();
            for (const i of e)i.startsWith(_) && await this.client.core.storage.removeItem(i);
        } catch (e) {
            this.logger.warn("Failed to cleanup storage", e);
        }
    }
}
const es = x;
;
 //# sourceMappingURL=index.es.js.map
}}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/ethereum-provider/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "EthereumProvider": (()=>z),
    "OPTIONAL_EVENTS": (()=>O),
    "OPTIONAL_METHODS": (()=>M),
    "REQUIRED_EVENTS": (()=>m),
    "REQUIRED_METHODS": (()=>u),
    "default": (()=>w)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$universal$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/universal-provider/dist/index.es.js [app-client] (ecmascript)");
;
;
;
const T = "wc", $ = "ethereum_provider", j = `${T}@2:${$}:`, q = "https://rpc.walletconnect.org/v1/", u = [
    "eth_sendTransaction",
    "personal_sign"
], M = [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    "wallet_getCallsStatus",
    "wallet_showCallsStatus"
], m = [
    "chainChanged",
    "accountsChanged"
], O = [
    "chainChanged",
    "accountsChanged",
    "message",
    "disconnect",
    "connect"
];
var N = Object.defineProperty, D = Object.defineProperties, U = Object.getOwnPropertyDescriptors, P = Object.getOwnPropertySymbols, Q = Object.prototype.hasOwnProperty, L = Object.prototype.propertyIsEnumerable, y = (a, t, s)=>t in a ? N(a, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: s
    }) : a[t] = s, g = (a, t)=>{
    for(var s in t || (t = {}))Q.call(t, s) && y(a, s, t[s]);
    if (P) for (var s of P(t))L.call(t, s) && y(a, s, t[s]);
    return a;
}, _ = (a, t)=>D(a, U(t)), o = (a, t, s)=>y(a, typeof t != "symbol" ? t + "" : t, s);
function v(a) {
    return Number(a[0].split(":")[1]);
}
function C(a) {
    return `0x${a.toString(16)}`;
}
function x(a) {
    const { chains: t, optionalChains: s, methods: i, optionalMethods: e, events: n, optionalEvents: h, rpcMap: l } = a;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidArray"])(t)) throw new Error("Invalid chains");
    const r = {
        chains: t,
        methods: i || u,
        events: n || m,
        rpcMap: g({}, t.length ? {
            [v(t)]: l[v(t)]
        } : {})
    }, d = n?.filter((p)=>!m.includes(p)), c = i?.filter((p)=>!u.includes(p));
    if (!s && !h && !e && !(d != null && d.length) && !(c != null && c.length)) return {
        required: t.length ? r : void 0
    };
    const I = d?.length && c?.length || !s, f = {
        chains: [
            ...new Set(I ? r.chains.concat(s || []) : s)
        ],
        methods: [
            ...new Set(r.methods.concat(e != null && e.length ? e : M))
        ],
        events: [
            ...new Set(r.events.concat(h != null && h.length ? h : O))
        ],
        rpcMap: l
    };
    return {
        required: t.length ? r : void 0,
        optional: s.length ? f : void 0
    };
}
class w {
    constructor(){
        o(this, "events", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"]), o(this, "namespace", "eip155"), o(this, "accounts", []), o(this, "signer"), o(this, "chainId", 1), o(this, "modal"), o(this, "rpc"), o(this, "STORAGE_KEY", j), o(this, "on", (t, s)=>(this.events.on(t, s), this)), o(this, "once", (t, s)=>(this.events.once(t, s), this)), o(this, "removeListener", (t, s)=>(this.events.removeListener(t, s), this)), o(this, "off", (t, s)=>(this.events.off(t, s), this)), o(this, "parseAccount", (t)=>this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t), this.signer = {}, this.rpc = {};
    }
    static async init(t) {
        const s = new w;
        return await s.initialize(t), s;
    }
    async request(t, s) {
        return await this.signer.request(t, this.formatChainId(this.chainId), s);
    }
    sendAsync(t, s, i) {
        this.signer.sendAsync(t, s, this.formatChainId(this.chainId), i);
    }
    get connected() {
        return this.signer.client ? this.signer.client.core.relayer.connected : !1;
    }
    get connecting() {
        return this.signer.client ? this.signer.client.core.relayer.connecting : !1;
    }
    async enable() {
        return this.session || await this.connect(), await this.request({
            method: "eth_requestAccounts"
        });
    }
    async connect(t) {
        if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts(t);
        const { required: s, optional: i } = x(this.rpc);
        try {
            const e = await new Promise(async (h, l)=>{
                var r;
                this.rpc.showQrModal && ((r = this.modal) == null || r.subscribeModal((c)=>{
                    !c.open && !this.signer.session && (this.signer.abortPairingAttempt(), l(new Error("Connection request reset. Please try again.")));
                }));
                const d = t != null && t.scopedProperties ? {
                    [this.namespace]: t.scopedProperties
                } : void 0;
                await this.signer.connect(_(g({
                    namespaces: g({}, s && {
                        [this.namespace]: s
                    })
                }, i && {
                    optionalNamespaces: {
                        [this.namespace]: i
                    }
                }), {
                    pairingTopic: t?.pairingTopic,
                    scopedProperties: d
                })).then((c)=>{
                    h(c);
                }).catch((c)=>{
                    l(new Error(c.message));
                });
            });
            if (!e) return;
            const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAccountsFromNamespaces"])(e.namespaces, [
                this.namespace
            ]);
            this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit("connect", {
                chainId: C(this.chainId)
            });
        } catch (e) {
            throw this.signer.logger.error(e), e;
        } finally{
            this.modal && this.modal.closeModal();
        }
    }
    async authenticate(t, s) {
        if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts({
            chains: t?.chains
        });
        try {
            const i = await new Promise(async (n, h)=>{
                var l;
                this.rpc.showQrModal && ((l = this.modal) == null || l.subscribeModal((r)=>{
                    !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), h(new Error("Connection request reset. Please try again.")));
                })), await this.signer.authenticate(_(g({}, t), {
                    chains: this.rpc.chains
                }), s).then((r)=>{
                    n(r);
                }).catch((r)=>{
                    h(new Error(r.message));
                });
            }), e = i.session;
            if (e) {
                const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAccountsFromNamespaces"])(e.namespaces, [
                    this.namespace
                ]);
                this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit("connect", {
                    chainId: C(this.chainId)
                });
            }
            return i;
        } catch (i) {
            throw this.signer.logger.error(i), i;
        } finally{
            this.modal && this.modal.closeModal();
        }
    }
    async disconnect() {
        this.session && await this.signer.disconnect(), this.reset();
    }
    get isWalletConnect() {
        return !0;
    }
    get session() {
        return this.signer.session;
    }
    registerEventListeners() {
        this.signer.on("session_event", (t)=>{
            const { params: s } = t, { event: i } = s;
            i.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i.data), this.events.emit("accountsChanged", this.accounts)) : i.name === "chainChanged" ? this.setChainId(this.formatChainId(i.data)) : this.events.emit(i.name, i.data), this.events.emit("session_event", t);
        }), this.signer.on("chainChanged", (t)=>{
            const s = parseInt(t);
            this.chainId = s, this.events.emit("chainChanged", C(this.chainId)), this.persist();
        }), this.signer.on("session_update", (t)=>{
            this.events.emit("session_update", t);
        }), this.signer.on("session_delete", (t)=>{
            this.reset(), this.events.emit("session_delete", t), this.events.emit("disconnect", _(g({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSdkError"])("USER_DISCONNECTED")), {
                data: t.topic,
                name: "USER_DISCONNECTED"
            }));
        }), this.signer.on("display_uri", (t)=>{
            var s, i;
            this.rpc.showQrModal && ((s = this.modal) == null || s.closeModal(), (i = this.modal) == null || i.openModal({
                uri: t
            })), this.events.emit("display_uri", t);
        });
    }
    switchEthereumChain(t) {
        this.request({
            method: "wallet_switchEthereumChain",
            params: [
                {
                    chainId: t.toString(16)
                }
            ]
        });
    }
    isCompatibleChainId(t) {
        return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : !1;
    }
    formatChainId(t) {
        return `${this.namespace}:${t}`;
    }
    parseChainId(t) {
        return Number(t.split(":")[1]);
    }
    setChainIds(t) {
        const s = t.filter((i)=>this.isCompatibleChainId(i)).map((i)=>this.parseChainId(i));
        s.length && (this.chainId = s[0], this.events.emit("chainChanged", C(this.chainId)), this.persist());
    }
    setChainId(t) {
        if (this.isCompatibleChainId(t)) {
            const s = this.parseChainId(t);
            this.chainId = s, this.switchEthereumChain(s);
        }
    }
    parseAccountId(t) {
        const [s, i, e] = t.split(":");
        return {
            chainId: `${s}:${i}`,
            address: e
        };
    }
    setAccounts(t) {
        this.accounts = t.filter((s)=>this.parseChainId(this.parseAccountId(s).chainId) === this.chainId).map((s)=>this.parseAccountId(s).address), this.events.emit("accountsChanged", this.accounts);
    }
    getRpcConfig(t) {
        var s, i;
        const e = (s = t?.chains) != null ? s : [], n = (i = t?.optionalChains) != null ? i : [], h = e.concat(n);
        if (!h.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
        const l = e.length ? t?.methods || u : [], r = e.length ? t?.events || m : [], d = t?.optionalMethods || [], c = t?.optionalEvents || [], I = t?.rpcMap || this.buildRpcMap(h, t.projectId), f = t?.qrModalOptions || void 0;
        return {
            chains: e?.map((p)=>this.formatChainId(p)),
            optionalChains: n.map((p)=>this.formatChainId(p)),
            methods: l,
            events: r,
            optionalMethods: d,
            optionalEvents: c,
            rpcMap: I,
            showQrModal: !!(t != null && t.showQrModal),
            qrModalOptions: f,
            projectId: t.projectId,
            metadata: t.metadata
        };
    }
    buildRpcMap(t, s) {
        const i = {};
        return t.forEach((e)=>{
            i[e] = this.getRpcUrl(e, s);
        }), i;
    }
    async initialize(t) {
        if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? v(this.rpc.chains) : v(this.rpc.optionalChains), this.signer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$universal$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniversalProvider"].init({
            projectId: this.rpc.projectId,
            metadata: this.rpc.metadata,
            disableProviderPing: t.disableProviderPing,
            relayUrl: t.relayUrl,
            storage: t.storage,
            storageOptions: t.storageOptions,
            customStoragePrefix: t.customStoragePrefix,
            telemetryEnabled: t.telemetryEnabled,
            logger: t.logger
        }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
            let s;
            try {
                const { WalletConnectModal: i } = await __turbopack_context__.r("[project]/node_modules/@walletconnect/modal/dist/index.js [app-client] (ecmascript, async loader)")(__turbopack_context__.i);
                s = i;
            } catch  {
                throw new Error("To use QR modal, please install @walletconnect/modal package");
            }
            if (s) try {
                this.modal = new s(g({
                    projectId: this.rpc.projectId
                }, this.rpc.qrModalOptions));
            } catch (i) {
                throw this.signer.logger.error(i), new Error("Could not generate WalletConnectModal Instance");
            }
        }
    }
    loadConnectOpts(t) {
        if (!t) return;
        const { chains: s, optionalChains: i, rpcMap: e } = t;
        s && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidArray"])(s) && (this.rpc.chains = s.map((n)=>this.formatChainId(n)), s.forEach((n)=>{
            this.rpc.rpcMap[n] = e?.[n] || this.getRpcUrl(n);
        })), i && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidArray"])(i) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i?.map((n)=>this.formatChainId(n)), i.forEach((n)=>{
            this.rpc.rpcMap[n] = e?.[n] || this.getRpcUrl(n);
        }));
    }
    getRpcUrl(t, s) {
        var i;
        return ((i = this.rpc.rpcMap) == null ? void 0 : i[t]) || `${q}?chainId=eip155:${t}&projectId=${s || this.rpc.projectId}`;
    }
    async loadPersistedSession() {
        if (this.session) try {
            const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), s = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];
            this.setChainIds(t ? [
                this.formatChainId(t)
            ] : s?.accounts), this.setAccounts(s?.accounts);
        } catch (t) {
            this.signer.logger.error("Failed to load persisted session, clearing state..."), this.signer.logger.error(t), await this.disconnect().catch((s)=>this.signer.logger.warn(s));
        }
    }
    reset() {
        this.chainId = 1, this.accounts = [];
    }
    persist() {
        this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
    }
    parseAccounts(t) {
        return typeof t == "string" || t instanceof String ? [
            this.parseAccount(t)
        ] : t.map((s)=>this.parseAccount(s));
    }
}
const z = w;
;
 //# sourceMappingURL=index.es.js.map
}}),
}]);

//# sourceMappingURL=node_modules_97c7fbf6._.js.map